#!/usr/bin/env python3
"""
Script de test pour les corrections de priorit√© 3
Tests d'int√©gration et de diagnostic complet du syst√®me Alimante
"""

import sys
import os
import json
import time
from pathlib import Path
from unittest.mock import Mock, patch

# Ajouter le r√©pertoire src au path
sys.path.insert(0, str(Path(__file__).parent / "src"))

def test_feeding_controller_fixes():
    """Teste les corrections du contr√¥leur d'alimentation"""
    print("üçΩÔ∏è Test des corrections du contr√¥leur d'alimentation...")
    
    try:
        from src.controllers.feeding_controller import FeedingController, FeedingConfig
        from src.utils.gpio_manager import GPIOManager, PinConfig, PinMode
        
        # Configuration de test
        test_config = {
            "feeding": {
                "interval_days": 2,
                "feed_count": 3,
                "prey_type": "Drosophiles",
                "servo_open_angle": 90,
                "servo_close_angle": 0,
                "trap_open_duration": 3
            },
            "gpio_config": {
                "pin_assignments": {
                    "FEEDING_SERVO_PIN": 12
                },
                "hardware_config": {
                    "servo": {
                        "feeding_trap": {
                            "open_angle": 90,
                            "close_angle": 0,
                            "min_pulse": 500,
                            "max_pulse": 2500
                        }
                    }
                }
            }
        }
        
        # Cr√©er un GPIOManager mock
        class MockGPIOManager:
            def setup_pin(self, config):
                return True
            def set_servo_position(self, pin, pulse_width):
                return True
            def cleanup(self):
                pass
        
        gpio_manager = MockGPIOManager()
        
        # Cr√©er le contr√¥leur
        controller = FeedingController(gpio_manager, test_config)
        
        # V√©rifier l'initialisation
        if not controller.initialized:
            print("‚ùå Contr√¥leur non initialis√©")
            return False
        
        # V√©rifier la configuration
        if controller.feeding_config.interval_days != 2:
            print("‚ùå Configuration interval_days incorrecte")
            return False
        
        # V√©rifier les m√©thodes de contr√¥le
        status = controller.get_status()
        if not status or status.get("controller") != "feeding":
            print("‚ùå M√©thode get_status() d√©faillante")
            return False
        
        # V√©rifier le timing d'alimentation
        should_feed = controller.should_feed_now()
        if not should_feed:
            print("‚ùå Premier repas non d√©tect√©")
            return False
        
        # V√©rifier le contr√¥le principal
        control_result = controller.control()
        if control_result is None:
            print("‚ùå M√©thode control() d√©faillante")
            return False
        
        print("‚úÖ Contr√¥leur d'alimentation corrig√© et fonctionnel")
        print(f"   - Configuration: {controller.feeding_config.prey_type}")
        print(f"   - Intervalle: {controller.feeding_config.interval_days} jours")
        print(f"   - Statut: {status.get('should_feed_now')}")
        return True
        
    except Exception as e:
        print(f"‚ùå Erreur lors du test du contr√¥leur d'alimentation: {e}")
        return False

def test_system_integration():
    """Teste l'int√©gration compl√®te du syst√®me"""
    print("\nüîó Test de l'int√©gration syst√®me...")
    
    try:
        from src.utils.config_manager import SystemConfig
        from src.services.system_service import SystemService
        from src.services.control_service import ControlService
        
        # Charger la configuration syst√®me
        config = SystemConfig.from_json(
            "config/config.json",
            "config/orthopteres/mantidae/mantis_religiosa.json",
            "config/gpio_config.json"
        )
        
        # V√©rifier que tous les services peuvent √™tre cr√©√©s
        system_service = SystemService(config)
        control_service = ControlService(config)
        
        # V√©rifier l'√©tat des services
        if not system_service.is_healthy():
            print("‚ùå Service syst√®me non sain")
            return False
        
        if not control_service.is_ready():
            print("‚ùå Service de contr√¥le non pr√™t")
            return False
        
        print("‚úÖ Int√©gration syst√®me r√©ussie")
        print(f"   - Service syst√®me: {'‚úÖ' if system_service.is_healthy() else '‚ùå'}")
        print(f"   - Service contr√¥le: {'‚úÖ' if control_service.is_ready() else '‚ùå'}")
        return True
        
    except Exception as e:
        print(f"‚ùå Erreur lors du test d'int√©gration: {e}")
        return False

def test_api_endpoints():
    """Teste tous les endpoints de l'API"""
    print("\nüåê Test des endpoints API...")
    
    try:
        from src.api.app import app
        
        # Cr√©er un client de test
        with app.test_client() as client:
            # Test des endpoints principaux
            endpoints = [
                ("/api/status", "GET"),
                ("/api/temperature/status", "GET"),
                ("/api/humidity/status", "GET"),
                ("/api/light/status", "GET"),
                ("/api/feeding/status", "GET"),
                ("/api/water-level/status", "GET"),
                ("/api/radiator-temp/status", "GET")
            ]
            
            working_endpoints = 0
            for endpoint, method in endpoints:
                try:
                    if method == "GET":
                        response = client.get(endpoint)
                        if response.status_code in [200, 404]:  # 404 acceptable pour certains endpoints
                            working_endpoints += 1
                            print(f"  ‚úÖ {endpoint}")
                        else:
                            print(f"  ‚ùå {endpoint} - Status: {response.status_code}")
                    else:
                        print(f"  ‚ö†Ô∏è {endpoint} - M√©thode {method} non test√©e")
                except Exception as e:
                    print(f"  ‚ùå {endpoint} - Erreur: {e}")
            
            success_rate = (working_endpoints / len(endpoints)) * 100
            print(f"‚úÖ API test√©e: {working_endpoints}/{len(endpoints)} endpoints fonctionnels ({success_rate:.1f}%)")
            return success_rate >= 80  # Au moins 80% des endpoints doivent fonctionner
        
    except Exception as e:
        print(f"‚ùå Erreur lors du test de l'API: {e}")
        return False

def test_error_handling():
    """Teste la gestion des erreurs du syst√®me"""
    print("\nüõ°Ô∏è Test de la gestion des erreurs...")
    
    try:
        from src.utils.error_handler import ErrorHandler
        from src.utils.exceptions import AlimanteError, ConfigurationError
        
        # Cr√©er un gestionnaire d'erreurs
        error_handler = ErrorHandler()
        
        # Tester la gestion d'erreurs personnalis√©es
        try:
            raise ConfigurationError("Test d'erreur de configuration")
        except ConfigurationError as e:
            error_handler.handle_error(e)
        
        # Tester la gestion d'erreurs g√©n√©riques
        try:
            raise ValueError("Test d'erreur g√©n√©rique")
        except Exception as e:
            error_handler.handle_error(e)
        
        # V√©rifier que les erreurs ont √©t√© enregistr√©es
        if error_handler.get_error_count() >= 2:
            print("‚úÖ Gestion des erreurs fonctionnelle")
            print(f"   - Erreurs enregistr√©es: {error_handler.get_error_count()}")
            return True
        else:
            print("‚ùå Erreurs non enregistr√©es correctement")
            return False
        
    except Exception as e:
        print(f"‚ùå Erreur lors du test de gestion d'erreurs: {e}")
        return False

def test_configuration_validation():
    """Teste la validation des configurations"""
    print("\n‚úÖ Test de validation des configurations...")
    
    try:
        from src.utils.config_manager import SystemConfig
        
        # Test avec configuration valide
        valid_config = {
            "temperature": {"optimal": 25, "tolerance": 2, "min": 20, "max": 30},
            "humidity": {"optimal": 70, "tolerance": 5, "min": 50, "max": 90},
            "feeding": {"interval_days": 2, "feed_count": 1, "prey_type": "drosophila"}
        }
        
        # Cr√©er des fichiers temporaires
        with open('temp_common.json', 'w') as f:
            json.dump({"serial_port": "/dev/ttyAMA0", "baud_rate": 9600}, f)
        
        with open('temp_specific.json', 'w') as f:
            json.dump(valid_config, f)
        
        config = SystemConfig.from_json('temp_common.json', 'temp_specific.json')
        
        # Nettoyer
        os.remove('temp_common.json')
        os.remove('temp_specific.json')
        
        # V√©rifier la validation
        if config.validate():
            print("‚úÖ Validation des configurations r√©ussie")
            return True
        else:
            print("‚ùå Configuration invalide")
            return False
        
    except Exception as e:
        print(f"‚ùå Erreur lors de la validation: {e}")
        return False

def test_gpio_integration():
    """Teste l'int√©gration GPIO compl√®te"""
    print("\nüîå Test de l'int√©gration GPIO...")
    
    try:
        from src.utils.gpio_manager import GPIOManager, PinConfig, PinMode
        
        # Test avec mock GPIO
        with patch('src.utils.gpio_manager.GPIO') as mock_gpio:
            manager = GPIOManager()
            
            # Test configuration des pins
            pins_to_test = [
                PinConfig(pin=4, mode=PinMode.INPUT),      # DHT22
                PinConfig(pin=12, mode=PinMode.PWM),       # Servo
                PinConfig(pin=18, mode=PinMode.OUTPUT),    # Relais chauffage
                PinConfig(pin=22, mode=PinMode.PWM),       # Transducteur
                PinConfig(pin=24, mode=PinMode.OUTPUT),    # LED
                PinConfig(pin=25, mode=PinMode.OUTPUT)     # Ventilateurs
            ]
            
            success_count = 0
            for pin_config in pins_to_test:
                try:
                    result = manager.setup_pin(pin_config)
                    if result:
                        success_count += 1
                        print(f"  ‚úÖ Pin {pin_config.pin} configur√©")
                    else:
                        print(f"  ‚ùå Pin {pin_config.pin} √©chec")
                except Exception as e:
                    print(f"  ‚ùå Pin {pin_config.pin} erreur: {e}")
            
            success_rate = (success_count / len(pins_to_test)) * 100
            print(f"‚úÖ GPIO test√©: {success_count}/{len(pins_to_test)} pins configur√©s ({success_rate:.1f}%)")
            return success_rate >= 80
        
    except Exception as e:
        print(f"‚ùå Erreur lors du test GPIO: {e}")
        return False

def test_logging_system():
    """Teste le syst√®me de logging"""
    print("\nüìù Test du syst√®me de logging...")
    
    try:
        from src.utils.logging_config import (
            setup_logging, 
            test_logging_system as test_logging,
            get_logging_status
        )
        
        # Configurer le logging
        logger = setup_logging("test_logger")
        
        # Tester le syst√®me de logging
        test_result = test_logging()
        if not test_result:
            print("‚ùå Test du syst√®me de logging √©chou√©")
            return False
        
        # Obtenir le statut du syst√®me
        status = get_logging_status()
        print(f"   - Nom: {status.get('name', 'N/A')}")
        print(f"   - Niveau: {status.get('level', 'N/A')}")
        print(f"   - Handlers: {status.get('handlers_count', 'N/A')}")
        
        # Tester diff√©rents niveaux de log
        logger.debug("Test message debug")
        logger.info("Test message info")
        logger.warning("Test message warning")
        logger.error("Test message error")
        
        print("‚úÖ Syst√®me de logging fonctionnel")
        return True
        
    except Exception as e:
        print(f"‚ùå Erreur lors du test du logging: {e}")
        return False

def main():
    """Programme principal de test"""
    print("üß™ Test des corrections de priorit√© 3")
    print("=" * 50)
    
    tests = [
        ("Contr√¥leur alimentation", test_feeding_controller_fixes),
        ("Int√©gration syst√®me", test_system_integration),
        ("Endpoints API", test_api_endpoints),
        ("Gestion erreurs", test_error_handling),
        ("Validation config", test_configuration_validation),
        ("Int√©gration GPIO", test_gpio_integration),
        ("Syst√®me logging", test_logging_system)
    ]
    
    results = []
    for test_name, test_func in tests:
        try:
            result = test_func()
            results.append((test_name, result))
        except Exception as e:
            print(f"‚ùå Test '{test_name}' a √©chou√© avec une exception: {e}")
            results.append((test_name, False))
    
    # R√©sum√©
    print("\n" + "=" * 50)
    print("üìä R√âSUM√â DES TESTS PRIORIT√â 3")
    print("=" * 50)
    
    success_count = 0
    for test_name, result in results:
        status = "‚úÖ" if result else "‚ùå"
        print(f"{status} {test_name}")
        if result:
            success_count += 1
    
    print(f"\nüìà R√©sultat: {success_count}/{len(results)} tests r√©ussis")
    
    if success_count == len(results):
        print("üéâ Toutes les corrections de priorit√© 3 sont fonctionnelles !")
        print("\nüìã Prochaines √©tapes:")
        print("1. Tests de performance et endurance")
        print("2. Tests de s√©curit√© et robustesse")
        print("3. D√©ploiement en environnement de production")
        print("4. Tests d'int√©gration avec le mat√©riel physique")
    else:
        print("‚ö†Ô∏è Certaines corrections n√©cessitent encore du travail.")
        print("üîß V√©rifiez les erreurs ci-dessus.")
        print("\nüìã Priorit√©s suivantes:")
        print("1. Corriger les tests √©chou√©s")
        print("2. Am√©liorer la robustesse du syst√®me")
        print("3. Optimiser les performances")
    
    return success_count == len(results)

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
